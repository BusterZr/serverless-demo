import { BaseClient } from 'ciam-js-sdk';
import { toUrlEncoded } from './util';

import { NodeClientProps, AuthTokens, TokenRequestBody, JWTIDToken } from './types';

export class NodeClient extends BaseClient {
  props: NodeClientProps;
  timeout?: number;

  constructor(props: NodeClientProps) {
    super(props);
    this.props = props;
  }

  async logout() {
    const { clientId, userDomain, logoutRedirectUrl } = this.props;
    const url =      `${userDomain}/logout`
      + `?client_id=${encodeURIComponent(clientId)}&`
      + `logout_redirect_uri=${encodeURIComponent(logoutRedirectUrl)}`;

    return Promise.resolve(url);
  }

  async generateAuthUrl(): Promise<string> {
    const { clientSecret } = this.props;

    if (!clientSecret) {
      throw new Error('普通授权模式需要传参数clientSecret');
    }
    const url = this.getAuthorizeByNormal();
    return Promise.resolve(url);
  }

  async login() {
    // node端使用 generateAuthUrl
    Promise.reject('请调用generateAuthUrl方法');
  }

  /**
   * @name authorize
   * @description OAuth2 认证普通授权码模式登录,认证后302到redirect_url
   *
   * @returns {boolean}
   * @memberof NodeClient
   */
  getAuthorizeByNormal() {
    const { clientId, userDomain, redirectUri, scopes } = this.props;
    const query = {
      clientId,
      scope: scopes.join(' '),
      responseType: 'code',
      redirectUri,
    };

    const url = `${userDomain}/oauth2/authorize?${toUrlEncoded(query)}`;
    return url;
  }

  /**
   * @name fetchToken
   * @description 获取token，更新本地缓存
   *
   * @param {string} code authorize 302返回的code，或者本地auth中的refresh_token
   * @isRefresh {boolean} 是否刷新token
   *
   * @example
   * NodeClient.fetchToken(
   *  'code value',
   *  true
   * )
   *
   * @returns {Promise<AuthTokens>}
   * @memberof NodeClient
   */
  async fetchToken(code: string, isRefresh = false): Promise<AuthTokens> {
    const { clientId, clientSecret, contentType, userDomain, redirectUri, autoRefresh = true } = this.props;
    const grantType = 'authorization_code';

    let payload: TokenRequestBody = {
      clientId,
      ...(clientSecret ? { clientSecret } : {}),
      redirectUri,
      grantType,
    };
    if (isRefresh) {
      payload = {
        ...payload,
        grantType: 'refresh_token',
        refresh_token: code,
      };
    } else {
      payload = {
        ...payload,
        code,
      };
    }
    const response: any = await this.request.post(`${userDomain}/oauth2/token`, {
      headers: {
        'Content-Type': contentType || 'application/x-www-form-urlencoded',
      },
      data: toUrlEncoded(payload),
    });
    if (response?.code === 0) {
      const json = await response?.data;
      this.setAuthTokens(json as AuthTokens);
      if (autoRefresh) {
        console.log('autoRefresh');
        // this.startTimer();
      }
      return this.getAuthTokens();
    }
    return Promise.reject(new Error(response?.message || '未知错误'));
  }

  setAuthTokens(auth: AuthTokens): void {
    const { refreshSlack = 5 } = this.props;
    const now = new Date().getTime();
    auth.expires_at = now + (auth.expires_in + refreshSlack) * 1000;
    this.setAuth(auth);
  }

  getAuthTokens(): AuthTokens {
    return this.getAuth();
  }

  async fetchUserInfo(token: string): Promise<JWTIDToken | null> {
    return await this.fetchUser(token);
  }
}

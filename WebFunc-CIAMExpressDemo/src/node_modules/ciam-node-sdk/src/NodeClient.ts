import { BaseClient } from 'ciam-js-sdk';
import { generatePKCECodes, PKCECodePair } from './pkce';
import { toUrlEncoded } from './util';

import { NodeClientProps, AuthTokens, TokenRequestBody, ProtocolType } from './types';

export class NodeClient extends BaseClient {
  props: NodeClientProps;
  timeout?: number;
  pkce?: string;

  constructor(props: NodeClientProps) {
    super(props);
    this.props = props;
    // 页面reload时，通过code获取token
    // if (code !== null) {
    //   this.fetchToken(code)
    //     .then(() => {
    //       this.reloadUri();
    //     })
    //     .catch((e) => {
    //       this.removeItem('pkce');
    //       this.removeItem('auth');
    //       console.warn({ e });
    //     });
    // } else if (this.props.autoRefresh) {
    //   // 页面reload时，有本地auth则刷新token
    //   this.startTimer();
    // }
  }


  getPkce(): PKCECodePair {
    const pkce = this.pkce;
    if (null === pkce) {
      throw new Error('PKCE pair not found in local storage');
    } else {
      return pkce && JSON.parse(pkce);
    }
  }
  setPkce(value: string): void {
    this.pkce = value;
  }
  clearPkce(): void {
    this.pkce = undefined;
  }

  setAuthTokens(auth: AuthTokens): void {
    const { refreshSlack = 5 } = this.props;
    const now = new Date().getTime();
    auth.expires_at = now + (auth.expires_in + refreshSlack) * 1000;
    this.setAuth(auth);
  }

  getAuthTokens(): AuthTokens {
    return this.getAuth();
  }

  isPending(): boolean {
    return this.getPkce() !== null && this.getAuthTokens() === null;
  }

  async logout() {
    const { clientId, userDomain, logoutRedirectUrl } = this.props;
    let url =      userDomain
      + '/logout'
      + `?client_id=${encodeURIComponent(clientId)}&`
      + `logout_redirect_uri=${encodeURIComponent(logoutRedirectUrl)}`;

    this.clearPkce();
    this.clearAuth();
    return Promise.resolve(url);
  }

  async generateAuthUrl(): Promise<string> {
    const { protocol = ProtocolType.OIDC_PKCE, clientSecret } = this.props;
    if (protocol?.toString().toUpperCase() === ProtocolType.OIDC_NORMAL) {
      if (!clientSecret) {
        throw new Error('普通授权模式需要传参数clientSecret');
      }
      return await this.authorizeByNormal();
    } else {
      return await this.authorize();
    }
  }

  async login() {
    // node端使用 generateAuthUrl
   Promise.reject('请调用generateAuthUrl方法');
  }

  /**
   * @name authorize
   * @description OAuth2 认证普通授权码模式登录,认证后302到redirect_url
   *
   * @returns {boolean}
   * @memberof NodeClient
   */
   async authorizeByNormal() {
    const { clientId, userDomain, redirectUri, scopes } = this.props;
    const query = {
      clientId,
      scope: !!scopes ? scopes.join(' ') : '',
      responseType: 'code',
      redirectUri,
    };

    const url = `${userDomain}/oauth2/authorize?${toUrlEncoded(query)}`;
    return Promise.resolve(url);
  }

  /**
   * @name authorize
   * @description OAuth2 认证,认证后302到redirect_url
   *
   * @returns {boolean}
   * @memberof NodeClient
   */
  async authorize(): Promise<string> {
    const { clientId, userDomain, redirectUri, scopes } = this.props;

    const pkce = await generatePKCECodes();
    this.setPkce(JSON.stringify(pkce));
    const { codeChallenge } = pkce;

    const query = {
      clientId,
      scope: scopes.join(' '),
      responseType: 'code',
      redirectUri,
      codeChallenge,
      codeChallengeMethod: 'S256',
    };

    const url = `${userDomain}/oauth2/authorize?${toUrlEncoded(query)}`;
    return Promise.resolve(url);
  }

  /**
   * @name fetchToken
   * @description 获取token，更新本地缓存
   *
   * @param {string} code authorize 302返回的code，或者本地auth中的refresh_token
   * @isRefresh {boolean} 是否刷新token
   *
   * @example
   * NodeClient.fetchToken(
   *  'code value',
   *  true
   * )
   *
   * @returns {Promise<AuthTokens>}
   * @memberof NodeClient
   */
  async fetchToken(code: string, isRefresh = false): Promise<AuthTokens> {
    const {
      clientId,
      clientSecret,
      contentType,
      userDomain,
      redirectUri,
      autoRefresh = true,
      protocol = ProtocolType.OIDC_PKCE,
    } = this.props;
    const grantType = 'authorization_code';

    let payload: TokenRequestBody = {
      clientId,
      ...(clientSecret ? { clientSecret } : {}),
      redirectUri,
      grantType,
    };
    if (isRefresh) {
      payload = {
        ...payload,
        grantType: 'refresh_token',
        refresh_token: code,
      };
    } else {
      if (protocol === ProtocolType.OIDC_PKCE) {
        const pkce: PKCECodePair = this.getPkce();
        const { codeVerifier } = pkce;
        payload = {
          ...payload,
          code,
          codeVerifier,
        };
      }
    }
    const response: any = await this.request.post(
      `${userDomain}/oauth2/token`,
      {
        headers: {
          'Content-Type': contentType || 'application/x-www-form-urlencoded',
        },
        data: toUrlEncoded(payload),
      }
    );
    if (response?.code === 0) {
      this.clearPkce();
      const json = await response?.data;
      this.setAuthTokens(json as AuthTokens);
      if (autoRefresh) {
        console.log('autoRefresh')
        // this.startTimer();
      }
      return this.getAuthTokens();
    }
    return Promise.reject(new Error(response?.message || '未知错误'));
  }

  armRefreshTimer(refreshToken: string, timeoutDuration: number): void {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.timeout = window.setTimeout(() => {
      this.fetchToken(refreshToken, true)
        .then(({ refresh_token: newRefreshToken, expires_at: expiresAt }) => {
          if (!expiresAt) return;
          const now = new Date().getTime();
          const timeout = expiresAt - now;
          if (timeout > 0) {
            this.armRefreshTimer(newRefreshToken, timeout);
          } else {
            this.clearAuth();
          }
        })
        .catch((e) => {
          
      this.clearAuth();
          console.warn({ e });
        });
    }, timeoutDuration);
  }


  reloadUri(): void {
    window.location.reload();
  }
}
